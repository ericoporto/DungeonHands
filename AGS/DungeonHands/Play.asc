// new module script
#define FX_TIMING 0.2
Character * cHero;
Character * cMonster;
Character * cTable;
GUI * GUI_HeroHand;
GUI * GUI_MonsterHand;
GUIControl * InvWindow_Hero;
GUIControl * InvWindow_Monster;
int turn_counter;
bool turn_monster;
bool turn_hero;
int phase;
bool playerd_monster_this_turn;
bool playerd_hero_this_turn;
bool advantage_hero;
bool advantage_monster;

void setAdvantage_Hero(){
  advantage_hero = true;
  advantage_monster = false;
}

void setAdvantage_Monster(){
  advantage_hero = false;
  advantage_monster = true;
}

void loseAllInventory(Character * c_to_lose){
  int i;
  i=1;
  while(i < Game.InventoryItemCount){
    int k;
    k=0;
    while(k<c_to_lose.InventoryQuantity[i]){
      c_to_lose.LoseInventory(inventory[i]);
      k++;  
    }
  
    i++;
  }
}

void Play_zeroItems(){
  loseAllInventory(cInvOwner1);
  loseAllInventory(cInvOwner2);
  loseAllInventory(cInvOwner3);
}

void start_round(){
  playerd_monster_this_turn=false;
  playerd_hero_this_turn=false;
}

void resolve_table(){
  loseAllInventory(cInvOwner3);
  if(turn_hero){
    setAdvantage_Hero();  
  } else {
    setAdvantage_Monster(); 
  }
}

Character * Play_Get_Char_Monster(){
  return cMonster;
}

Character * Play_Get_Char_Hero(){
  return cHero;
}

function playerMonster_DrawQuick(){
  cMonster.AddInventory(Cards_MC_CardToItem(Cards_drawCard_MC()));
}


function playerHero_DrawQuick(){
  cHero.AddInventory(Cards_HC_CardToItem(Cards_drawCard_HC()));
}

function playerMonster_Draw(){
  int card = Cards_drawCard_MC();
  gFloatingDrawCard.Visible=true;
  gFloatingDrawCard.BackgroundGraphic = Card_MC_getCardGraphic(card);
  gFloatingDrawCard.X = gDeckMonster.X;
  gFloatingDrawCard.Y = gDeckMonster.Y;
  int d_x = GUI_MonsterHand.X + InvWindow_Monster.X+ InvWindow_Monster.AsInvWindow.ItemCount*InvWindow_Monster.AsInvWindow.ItemWidth;
  int d_y = GUI_MonsterHand.Y+InvWindow_Monster.Y; 
  gFloatingDrawCard.TweenPosition(FX_TIMING, d_x, d_y, eEaseLinearTween, eBlockTween);
  gFloatingDrawCard.Visible = false;
  cMonster.AddInventory(Cards_MC_CardToItem(card));
}


function playerHero_Draw(){
  int card = Cards_drawCard_HC();
  gFloatingDrawCard.Visible=true;
  gFloatingDrawCard.BackgroundGraphic = Card_HC_getCardGraphic(card);
  gFloatingDrawCard.X = gDeckHero.X;
  gFloatingDrawCard.Y = gDeckHero.Y;
  int d_x = GUI_HeroHand.X + InvWindow_Hero.X+ InvWindow_Hero.AsInvWindow.ItemCount*InvWindow_Hero.AsInvWindow.ItemWidth;
  int d_y = GUI_HeroHand.Y+InvWindow_Hero.Y;
  gFloatingDrawCard.TweenPosition(FX_TIMING, d_x, d_y, eEaseLinearTween, eBlockTween);
  gFloatingDrawCard.Visible = false;
  cHero.AddInventory(Cards_HC_CardToItem(card));
  
}


void setMonsterTurn(){
  turn_hero=false;
  GUI_HeroHand.Clickable = false;
  GUI_HeroHand.Transparency = 50;
  
  turn_monster=true;
  GUI_MonsterHand.Clickable = true;
  GUI_MonsterHand.Transparency = 0;
  
}

void setHeroTurn(){
  turn_monster=false;
  GUI_MonsterHand.Clickable = false;
  GUI_MonsterHand.Transparency = 50;
  
  turn_hero=true;
  GUI_HeroHand.Clickable = true;
  GUI_HeroHand.Transparency = 0;
  
}

void next_turn(){
  turn_counter++;
  if(turn_counter%2==0){
    start_round();
    //it's the first turn in round
    if(advantage_hero){
      setHeroTurn(); 
    } else {
      setMonsterTurn();
    }
  } else {
    //it's the second turn in round
    if(turn_hero){
      setMonsterTurn();
    } else {
      setHeroTurn();
    }
    
  }
  
 
}

void Play_next_turn(){
  next_turn();
}

void Play_End_Turn(){
  if(playerd_hero_this_turn && playerd_monster_this_turn){
    resolve_table();
  }
  Play_next_turn();
}

void Play_Hero_Played_Card(InventoryItem * invItm){
  int card = Cards_HC_ItemToCard(invItm);
  playerd_hero_this_turn=true;
  if(!Card_HC_isCardSpecial(card)){
    Play_End_Turn();
  }
  
  
}

void Play_Monster_Played_Card(InventoryItem * invItm){
  int card = Cards_MC_ItemToCard(invItm);
  playerd_monster_this_turn=true;
  if(!Card_MC_isCardSpecial(card)){
    Play_End_Turn();
  }
}

function Play_deckDraw_MC(){
  if(turn_monster){
    playerMonster_Draw();
  }
}

function Play_deckDraw_HC(){
  if(turn_hero){
    playerHero_Draw();
  }
  
}

void drawHands(){
  int n_cards;
  n_cards=7;
  while(n_cards>0){
    playerMonster_DrawQuick();
    n_cards--;
  }
  
  n_cards=7;
  while(n_cards>0){
    playerHero_DrawQuick();
    n_cards--;
  }
}

function Play_begin(){
  turn_counter=0;
  gDeckHero.Visible = true;
  gDeckMonster.Visible = true;
  Play_zeroItems();
  Cards_makeDecks();
  drawHands();
  setAdvantage_Monster();
  start_round();
}

function game_start(){
  cHero = cInvOwner1 ;
  cMonster = cInvOwner2 ;
  cTable = cInvOwner3;
  GUI_HeroHand=gItemExchange1;
  GUI_MonsterHand=gItemExchange2;
  InvWindow_Hero = InventoryWindow1;
  InvWindow_Monster = InventoryWindow2;
  Play_begin();
  if(Random(2)==0){
    setHeroTurn();
    setAdvantage_Hero();
  } else {
    setMonsterTurn();
    setAdvantage_Monster();
  }
}
